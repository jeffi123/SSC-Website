import {
  __export,
  defineComponent,
  h,
  reactive,
  ref,
  watch
} from "./chunk-ULA35Y3P.js";

// node_modules/@inkline/inkline/components/index.mjs
var components_exports = {};
__export(components_exports, {
  IAlert: () => default19,
  IBadge: () => default20,
  IBreadcrumb: () => default21,
  IBreadcrumbItem: () => default2,
  IButton: () => default22,
  IButtonGroup: () => default23,
  ICard: () => default26,
  ICheckbox: () => default27,
  ICheckboxGroup: () => default3,
  ICollapsible: () => default28,
  ICollapsibleItem: () => default4,
  IColumn: () => default24,
  IContainer: () => default25,
  IDropdown: () => default29,
  IDropdownDivider: () => default5,
  IDropdownItem: () => default6,
  IForm: () => default30,
  IFormError: () => default8,
  IFormGroup: () => default7,
  IFormLabel: () => default9,
  IHamburgerMenu: () => default31,
  IHeader: () => default32,
  IIcon: () => default33,
  IInput: () => default34,
  ILayout: () => default37,
  ILayoutAside: () => default38,
  ILayoutContent: () => default39,
  ILayoutFooter: () => default40,
  ILayoutHeader: () => default41,
  IListGroup: () => default42,
  IListGroupItem: () => default10,
  ILoader: () => default43,
  IMark: () => default44,
  IMedia: () => default45,
  IModal: () => default46,
  INav: () => default47,
  INavItem: () => default11,
  INavbar: () => default48,
  INavbarBrand: () => default12,
  INavbarCollapsible: () => default13,
  INumberInput: () => default35,
  IPagination: () => default49,
  IPopover: () => default50,
  IProgress: () => default51,
  IProgressBar: () => default14,
  IRadio: () => default52,
  IRadioGroup: () => default15,
  IRow: () => default53,
  ISelect: () => default54,
  ISelectOption: () => default16,
  ISidebar: () => default55,
  ITab: () => default17,
  ITabTitle: () => default18,
  ITable: () => default56,
  ITabs: () => default57,
  ITextarea: () => default36,
  IToggle: () => default58,
  ITooltip: () => default59
});
import { default as default19 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IAlert/index.vue";
import { default as default20 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IBadge/index.vue";
import { default as default21 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IBreadcrumb/index.vue";

// node_modules/@inkline/inkline/components/IBreadcrumb/components/index.mjs
import { default as default2 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IBreadcrumb/components/IBreadcrumbItem/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default22 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IButton/index.vue";
import { default as default23 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IButtonGroup/index.vue";
import { default as default24 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IColumn/index.vue";
import { default as default25 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IContainer/index.vue";
import { default as default26 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ICard/index.vue";
import { default as default27 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ICheckbox/index.vue";

// node_modules/@inkline/inkline/components/ICheckbox/components/index.mjs
import { default as default3 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ICheckbox/components/ICheckboxGroup/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default28 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ICollapsible/index.vue";

// node_modules/@inkline/inkline/components/ICollapsible/components/index.mjs
import { default as default4 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ICollapsible/components/ICollapsibleItem/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default29 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IDropdown/index.vue";

// node_modules/@inkline/inkline/components/IDropdown/components/index.mjs
import { default as default5 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IDropdown/components/IDropdownDivider/index.vue";
import { default as default6 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IDropdown/components/IDropdownItem/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default30 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IForm/index.vue";

// node_modules/@inkline/inkline/components/IForm/components/index.mjs
import { default as default7 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IForm/components/IFormGroup/index.vue";
import { default as default8 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IForm/components/IFormError/index.vue";
import { default as default9 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IForm/components/IFormLabel/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default31 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IHamburgerMenu/index.vue";
import { default as default32 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IHeader/index.vue";
import { default as default33 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IIcon/index.vue";
import { default as default34 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IInput/index.vue";
import { default as default35 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/INumberInput/index.vue";
import { default as default36 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ITextarea/index.vue";
import { default as default37 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ILayout/index.vue";
import { default as default38 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ILayout/components/ILayoutAside/index.vue";
import { default as default39 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ILayout/components/ILayoutContent/index.vue";
import { default as default40 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ILayout/components/ILayoutFooter/index.vue";
import { default as default41 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ILayout/components/ILayoutHeader/index.vue";
import { default as default42 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IListGroup/index.vue";

// node_modules/@inkline/inkline/components/IListGroup/components/index.mjs
import { default as default10 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IListGroup/components/IListGroupItem/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default43 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ILoader/index.vue";
import { default as default44 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IMark/index.vue";
import { default as default45 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IMedia/index.vue";
import { default as default46 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IModal/index.vue";
import { default as default47 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/INav/index.vue";

// node_modules/@inkline/inkline/components/INav/components/index.mjs
import { default as default11 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/INav/components/INavItem/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default48 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/INavbar/index.vue";

// node_modules/@inkline/inkline/components/INavbar/components/index.mjs
import { default as default12 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/INavbar/components/INavbarBrand/index.vue";
import { default as default13 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/INavbar/components/INavbarCollapsible/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default49 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IPagination/index.vue";
import { default as default50 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IPopover/index.vue";
import { default as default51 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IProgress/index.vue";

// node_modules/@inkline/inkline/components/IProgress/components/index.mjs
import { default as default14 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IProgress/components/IProgressBar/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default52 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IRadio/index.vue";

// node_modules/@inkline/inkline/components/IRadio/components/index.mjs
import { default as default15 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IRadio/components/IRadioGroup/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default53 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IRow/index.vue";
import { default as default54 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ISelect/index.vue";

// node_modules/@inkline/inkline/components/ISelect/components/index.mjs
import { default as default16 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ISelect/components/ISelectOption/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default55 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ISidebar/index.vue";
import { default as default56 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ITable/index.vue";
import { default as default57 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ITabs/index.vue";

// node_modules/@inkline/inkline/components/ITabs/components/index.mjs
import { default as default17 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ITabs/components/ITab/index.vue";
import { default as default18 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ITabs/components/ITabTitle/index.vue";

// node_modules/@inkline/inkline/components/index.mjs
import { default as default58 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/IToggle/index.vue";
import { default as default59 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/components/ITooltip/index.vue";

// node_modules/@inkline/inkline/validation/validators/constants.mjs
var alpha = {
  "en-US": /^[A-Z]+$/i,
  "bg-BG": /^[А-Я]+$/i,
  "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
  "da-DK": /^[A-ZÆØÅ]+$/i,
  "de-DE": /^[A-ZÄÖÜß]+$/i,
  "el-GR": /^[Α-ω]+$/i,
  "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i,
  "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
  "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
  "nb-NO": /^[A-ZÆØÅ]+$/i,
  "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
  "nn-NO": /^[A-ZÆØÅ]+$/i,
  "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
  "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
  "pt-PT": /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
  "ru-RU": /^[А-ЯЁ]+$/i,
  "sl-SI": /^[A-ZČĆĐŠŽ]+$/i,
  "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
  "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i,
  "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i,
  "sv-SE": /^[A-ZÅÄÖ]+$/i,
  "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i,
  "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i,
  "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
};
var alphanumeric = {
  "en-US": /^[0-9A-Z]+$/i,
  "bg-BG": /^[0-9А-Я]+$/i,
  "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
  "da-DK": /^[0-9A-ZÆØÅ]+$/i,
  "de-DE": /^[0-9A-ZÄÖÜß]+$/i,
  "el-GR": /^[0-9Α-ω]+$/i,
  "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
  "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
  "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
  "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
  "nb-NO": /^[0-9A-ZÆØÅ]+$/i,
  "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
  "nn-NO": /^[0-9A-ZÆØÅ]+$/i,
  "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
  "pt-PT": /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
  "ru-RU": /^[0-9А-ЯЁ]+$/i,
  "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i,
  "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
  "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i,
  "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
  "sv-SE": /^[0-9A-ZÅÄÖ]+$/i,
  "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
  "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
  "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
};
var decimal = {
  "en-US": ".",
  ar: "٫"
};
var arabicLocales = [
  "AE",
  "BH",
  "DZ",
  "EG",
  "IQ",
  "JO",
  "KW",
  "LB",
  "LY",
  "MA",
  "QM",
  "QA",
  "SA",
  "SD",
  "SY",
  "TN",
  "YE"
];
var englishLocales = [
  "AU",
  "GB",
  "HK",
  "IN",
  "NZ",
  "ZA",
  "ZM"
];
var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
var commaDecimal = [
  "bg-BG",
  "cs-CZ",
  "da-DK",
  "de-DE",
  "el-GR",
  "en-ZM",
  "es-ES",
  "fr-FR",
  "it-IT",
  "ku-IQ",
  "hu-HU",
  "nb-NO",
  "nn-NO",
  "nl-NL",
  "pl-PL",
  "pt-PT",
  "ru-RU",
  "sl-SI",
  "sr-RS@latin",
  "sr-RS",
  "sv-SE",
  "tr-TR",
  "uk-UA"
];
englishLocales.forEach((locale) => {
  alpha[`en-${locale}`] = alpha["en-US"];
  alphanumeric[`en-${locale}`] = alphanumeric["en-US"];
  decimal[`en-${locale}`] = decimal["en-US"];
});
arabicLocales.forEach((locale) => {
  alpha[`ar-${locale}`] = alpha.ar;
  alphanumeric[`ar-${locale}`] = alphanumeric.ar;
  decimal[`ar-${locale}`] = decimal.ar;
});
dotDecimal.forEach((locale) => {
  decimal[locale] = decimal["en-US"];
});
commaDecimal.forEach((locale) => {
  decimal[locale] = decimal.ar;
});
alpha["pt-BR"] = alpha["pt-PT"];
alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
decimal["pt-BR"] = decimal["pt-PT"];
alpha["pl-Pl"] = alpha["pl-PL"];
alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
decimal["pl-Pl"] = decimal["pl-PL"];

// node_modules/@inkline/inkline/validation/validators/alpha.mjs
function alpha2(rawValue, options = {}) {
  const locale = options.locale || "en-US";
  const process2 = (v) => {
    let value = String(v);
    if (options.allowDashes) {
      value = value.replace(/-/g, "");
    }
    if (options.allowSpaces) {
      value = value.replace(/ /g, "");
    }
    return value;
  };
  if (rawValue.constructor === Array) {
    return rawValue.every((v) => alpha[locale].test(process2(v)));
  }
  return alpha[locale].test(process2(rawValue));
}

// node_modules/@inkline/inkline/validation/validators/alphanumeric.mjs
function alphanumeric2(rawValue, options = {}) {
  const locale = options.locale || "en-US";
  const process2 = (v) => {
    let value = String(v);
    if (options.allowDashes) {
      value = value.replace(/-/g, "");
    }
    if (options.allowSpaces) {
      value = value.replace(/ /g, "");
    }
    return value;
  };
  if (rawValue.constructor === Array) {
    return rawValue.every((v) => alphanumeric[locale].test(process2(v)));
  }
  return alphanumeric[locale].test(process2(rawValue));
}

// node_modules/@inkline/inkline/validation/validators/custom.mjs
function custom(value, options = { validator: () => true }) {
  if (value.constructor === Array) {
    return value.every((v) => options.validator(v));
  }
  return options.validator(value);
}

// node_modules/@inkline/inkline/validation/validators/number.mjs
function number(value, options = { allowNegative: false, allowDecimal: false }) {
  let regExpString = "\\d+";
  if (options.allowNegative) {
    regExpString = "[-]?" + regExpString;
  }
  if (options.allowDecimal) {
    regExpString += "([\\.\\,]\\d+)?";
  }
  const regExp = new RegExp(`^${regExpString}$`);
  if (value.constructor === Array) {
    return value.every((v) => regExp.test(v));
  }
  return regExp.test(value);
}

// node_modules/@inkline/inkline/validation/validators/email.mjs
var validator = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
function email(value) {
  if (value.constructor === Array) {
    return value.every((v) => !v || validator.test(String(v)));
  }
  return !value || validator.test(String(value));
}

// node_modules/@inkline/inkline/validation/validators/max.mjs
function max(value, options = { value: 0 }) {
  if (value === void 0 || value === null) {
    return false;
  }
  const process2 = (v) => Number(v);
  if (Array.isArray(value)) {
    return value.every((v) => process2(v) <= options.value);
  }
  return process2(value) <= options.value;
}

// node_modules/@inkline/inkline/validation/validators/maxLength.mjs
function maxLength(value, options = { value: 0 }) {
  if (value === void 0 || value === null) {
    return false;
  }
  if (value.constructor === Array) {
    return value.length <= options.value;
  }
  if (typeof value === "object") {
    return Object.keys(value).length <= options.value;
  }
  return String(value).length <= options.value;
}

// node_modules/@inkline/inkline/validation/validators/min.mjs
function min(value, options = { value: 0 }) {
  if (value === void 0 || value === null) {
    return false;
  }
  const process2 = (v) => Number(v);
  if (Array.isArray(value)) {
    return value.every((v) => process2(v) >= options.value);
  }
  return process2(value) >= options.value;
}

// node_modules/@inkline/inkline/validation/validators/minLength.mjs
function minLength(value, options = { value: 0 }) {
  if (value === void 0 || value === null) {
    return false;
  }
  if (value.constructor === Array) {
    return value.length >= options.value;
  }
  if (typeof value === "object") {
    return Object.keys(value).length >= options.value;
  }
  return String(value).length >= options.value;
}

// node_modules/@inkline/inkline/validation/validators/required.mjs
function required(value, options = { invalidateFalse: false }) {
  if (value === void 0 || value === null) {
    return false;
  }
  if (value.constructor === Array) {
    return !!value.length;
  }
  if (typeof value === "boolean") {
    return options.invalidateFalse ? value : true;
  }
  return !!String(value).trim().length;
}

// node_modules/@inkline/inkline/helpers/hasClass.mjs
function hasClass(element, className) {
  if (!element || !className)
    return false;
  if (className.indexOf(" ") !== -1)
    throw new Error("Class name should not contain spaces.");
  if (element.classList) {
    return element.classList.contains(className);
  } else {
    return (" " + element.className + " ").indexOf(" " + className + " ") > -1;
  }
}

// node_modules/@inkline/inkline/helpers/addClass.mjs
function addClass(element, classes) {
  if (!element)
    return;
  let currentClass = element.className;
  const classList = (classes || "").split(" ");
  for (let i = 0, j = classList.length; i < j; i++) {
    const className = classList[i];
    if (!className)
      continue;
    if (element.classList) {
      element.classList.add(className);
    } else if (!hasClass(element, className)) {
      currentClass += " " + className;
    }
  }
  if (!element.classList) {
    element.className = currentClass;
  }
}

// node_modules/@inkline/inkline/helpers/toDashCase.mjs
function toDashCase(string, from = "camel") {
  const regExp = from === "camel" ? /([A-Z])/g : /_([a-zA-Z])/g;
  return string.replace(regExp, (match, p) => "-" + p.toLowerCase());
}

// node_modules/@inkline/inkline/helpers/breakpointClass.mjs
function breakpointClass(className, breakpoint) {
  if (["string", "number"].indexOf(typeof breakpoint) > -1 && breakpoint !== "") {
    return `${toDashCase(className)}-${breakpoint}`;
  }
  return toDashCase(className);
}

// node_modules/@inkline/inkline/helpers/capitalizeFirst.mjs
function capitalizeFirst(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// node_modules/@inkline/inkline/helpers/clone.mjs
function clone(source) {
  if (Array.isArray(source)) {
    const target = source.slice().map(clone);
    const targetKeys = Object.keys(target);
    Object.keys(source).filter((key) => !targetKeys.includes(key)).forEach((key) => {
      target[key] = source[key];
    });
    return target;
  } else if (typeof source === "object") {
    return Object.keys(source).reduce((acc, key) => {
      acc[key] = clone(source[key]);
      return acc;
    }, {});
  }
  return source;
}

// node_modules/@inkline/inkline/helpers/debounce.mjs
function debounce(fn2, delay) {
  let inDebounce;
  return function(...args) {
    const context = this;
    clearTimeout(inDebounce);
    inDebounce = setTimeout(() => fn2.apply(context, args), delay);
  };
}

// node_modules/@inkline/inkline/helpers/isFocusable.mjs
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element.disabled) {
    return false;
  }
  switch (element.nodeName) {
    case "A":
      return !!element.href && element.rel !== "ignore";
    case "INPUT":
      return element.type !== "hidden" && element.type !== "file";
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return true;
    default:
      return false;
  }
}

// node_modules/@inkline/inkline/helpers/focusAttempt.mjs
function focusAttempt(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus();
  } catch (e) {
  }
  return typeof window !== "undefined" && document.activeElement === element;
}

// node_modules/@inkline/inkline/helpers/focusFirstDescendant.mjs
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (focusAttempt(child) || focusFirstDescendant(child)) {
      return true;
    }
  }
  return false;
}

// node_modules/@inkline/inkline/helpers/focusLastDescendant.mjs
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (focusAttempt(child) || focusLastDescendant(child)) {
      return true;
    }
  }
  return false;
}

// node_modules/@inkline/inkline/helpers/getStyleProperty.mjs
function getStyleProperty(element, property) {
  if (!element || !property || typeof window === "undefined") {
    return;
  }
  if (element.currentStyle) {
    return element.currentStyle[property];
  }
  const computedStyle = window.getComputedStyle(element, null);
  return computedStyle.getPropertyValue ? computedStyle.getPropertyValue(property) : computedStyle[property];
}

// node_modules/@inkline/inkline/helpers/hashString.mjs
function hashString(string) {
  let hash3 = 0;
  if (string.length === 0) {
    return hash3;
  }
  for (let i = 0; i < string.length; i++) {
    hash3 = (hash3 << 5) - hash3 + string.charCodeAt(i);
    hash3 = hash3 & hash3;
  }
  return hash3;
}

// node_modules/@inkline/inkline/helpers/isFunction.mjs
var isFunction = (fn2) => fn2 instanceof Function;

// node_modules/@inkline/inkline/constants/breakpoints.mjs
var breakpoints = {
  xs: [0, 575],
  sm: [576, 767],
  md: [768, 991],
  lg: [992, 1199],
  xl: [1200, 1399],
  xxl: [1400, Infinity]
};
var breakpointKeys = ["", "xs", "sm", "md", "lg", "xl", "xxl"];

// node_modules/@inkline/inkline/constants/keymap.mjs
var keymap = {
  tab: ["Tab", 9],
  enter: ["Enter", 13],
  esc: ["Escape", 27],
  space: [" ", "Space", 32],
  left: ["ArrowLeft", "Left", 37],
  up: ["ArrowUp", "Up", 38],
  right: ["ArrowRight", "Right", 39],
  down: ["ArrowDown", "Down", 40]
};

// node_modules/@inkline/inkline/constants/eventValueMap.mjs
var eventValueMap = {
  input: (e) => e,
  blur: (e) => e.target.value,
  focus: (e) => e.target.value,
  mouseenter: (e) => e.target.value,
  mouseleave: (e) => e.target.value
};

// node_modules/@inkline/inkline/constants/validation.mjs
var defaultValidationValues = {
  pristine: true,
  dirty: false,
  untouched: true,
  touched: false,
  valid: true,
  invalid: false,
  errors: []
};
var defaultFieldValidationValues = {
  value: "",
  validators: []
};
var reservedValidationFields = [
  "value",
  "validators",
  "pristine",
  "dirty",
  "untouched",
  "touched",
  "valid",
  "invalid",
  "errors"
];

// node_modules/@inkline/inkline/helpers/isKey.mjs
var isKey = (key, e) => {
  const keyCode = e.key || e.keyIdentifier || e.keyCode;
  return keymap[key].indexOf(keyCode) !== -1;
};

// node_modules/@inkline/inkline/helpers/isMobile.mjs
function isMobile() {
  if (typeof window === "undefined") {
    return false;
  }
  const userAgent = navigator.userAgent || navigator.vendor || window.opera;
  if (typeof isMobile.cachedValue === "undefined") {
    isMobile.cachedValue = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(userAgent.substr(0, 4));
  }
  return isMobile.cachedValue;
}

// node_modules/@inkline/inkline/helpers/isVisible.mjs
function isVisible(element) {
  return Boolean(element) && Boolean(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
}

// node_modules/@inkline/inkline/helpers/markSearchString.mjs
function markSearchString(text, query) {
  if (!query)
    return [{ text }];
  const chunks = [];
  const lowerText = text.toLowerCase();
  const lowerQuery = query.toLowerCase();
  let start2 = 0;
  let end2 = 0;
  while (end2 < text.length) {
    const foundIdx = lowerText.indexOf(lowerQuery, end2);
    const found = foundIdx >= 0;
    end2 = found ? foundIdx : text.length;
    if (end2) {
      chunks.push({ text: text.substring(start2, end2) });
      start2 = end2;
    }
    if (found) {
      end2 += query.length;
      chunks.push({
        text: text.substring(start2, end2),
        marked: true
      });
      start2 = end2;
    }
  }
  return chunks;
}

// node_modules/@inkline/inkline/helpers/memoize.mjs
function memoize(fn2) {
  const cache = {};
  return (...args) => {
    const cacheKey = JSON.stringify(args);
    if (cacheKey in cache) {
      return cache[cacheKey];
    }
    cache[cacheKey] = fn2(...args);
    return cache[cacheKey];
  };
}

// node_modules/@inkline/inkline/helpers/off.mjs
function removeEventListenerBinding(element, event, handler) {
  if (element && event) {
    element.removeEventListener(event, handler, false);
  }
}
function detachEventBinding(element, event, handler) {
  if (element && event) {
    element.detachEvent("on" + event, handler);
  }
}
var _off = () => {
  if (typeof window === "undefined") {
    return () => {
    };
  }
  if (window.document.removeEventListener) {
    return removeEventListenerBinding;
  } else {
    return detachEventBinding;
  }
};
var off = _off();

// node_modules/@inkline/inkline/helpers/on.mjs
function addEventListenerBinding(element, event, handler) {
  if (element && event && handler) {
    element.addEventListener(event, handler, false);
  }
}
function attachEventBinding(element, event, handler) {
  if (element && event && handler) {
    element.attachEvent("on" + event, handler);
  }
}
var _on = () => {
  if (typeof window === "undefined") {
    return () => {
    };
  }
  if (window.document.addEventListener) {
    return addEventListenerBinding;
  } else {
    return attachEventBinding;
  }
};
var on = _on();

// node_modules/@inkline/inkline/helpers/once.mjs
var once = function(el, event, fn2) {
  const listener = function(...args) {
    if (fn2) {
      fn2.apply(this, args);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};

// node_modules/@inkline/inkline/helpers/query.mjs
function querySelector(items, name, maxDepth = 3, currentDepth = 0) {
  let result;
  for (const item of items) {
    const children = item.$children || (item.componentInstance || {}).$children || item.children;
    if ((item.$options || {}).name === name || ((item.$options || {}).extends || {}).name === name || ((item.componentInstance || {}).$options || {}).name === name || (((item.componentInstance || {}).$options || {}).extends || {}).name === name) {
      result = item;
    }
    if (children && children.length > 0 && currentDepth < maxDepth && !result) {
      result = querySelector(children, name, maxDepth, currentDepth + 1);
    }
    if (result) {
      break;
    }
  }
  return result;
}
function querySelectorAll(items, name, maxDepth = 3, currentDepth = 0) {
  let results = [];
  if (!items) {
    return results;
  }
  for (const item of items) {
    const children = item.$children || (item.componentInstance || {}).$children || item.children;
    if ((item.$options || {}).name === name || ((item.$options || {}).extends || {}).name === name || ((item.componentInstance || {}).$options || {}).name === name || (((item.componentInstance || {}).$options || {}).extends || {}).name === name) {
      results.push(item);
    }
    if (children && children.length > 0 && currentDepth < maxDepth) {
      results = results.concat(querySelectorAll(children, name, maxDepth, currentDepth + 1));
    }
  }
  return results;
}

// node_modules/@inkline/inkline/helpers/renderSvg.mjs
var renderSvg = (children) => children.map((child) => child.type === "element" ? h(child.name, child.attributes, renderSvg(child.children)) : child.value);

// node_modules/@inkline/inkline/helpers/trim.mjs
function trim(string) {
  return (string || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
}

// node_modules/@inkline/inkline/helpers/removeClass.mjs
function removeClass(element, classes) {
  if (!element || !classes) {
    return;
  }
  const classList = classes.split(" ");
  let currentClass = " " + element.className + " ";
  for (let i = 0, j = classList.length; i < j; i++) {
    const className = classList[i];
    if (!className) {
      continue;
    }
    if (element.classList) {
      element.classList.remove(className);
    } else if (hasClass(element, className)) {
      currentClass = currentClass.replace(" " + className + " ", " ");
    }
  }
  if (!element.classList) {
    element.className = trim(currentClass);
  }
}

// node_modules/@inkline/inkline/helpers/slugify.mjs
function slugify(string) {
  return string.toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}

// node_modules/@inkline/inkline/helpers/valueByPath.mjs
function getValueByPath(object, path) {
  return path.split(".").reduce((acc, part) => {
    return acc && acc[part];
  }, object);
}
function setValueByPath(object, path, key, value) {
  getValueByPath(object, path)[key] = value;
  return object;
}
function setValuesAlongPath(object, path, values) {
  if (path) {
    path.split(".").reduce((acc, part) => {
      Object.keys(values).forEach((key) => {
        acc[part][key] = values[key];
      });
      return acc && acc[part];
    }, object);
  }
  Object.keys(values).forEach((key) => {
    object[key] = values[key];
  });
  return object;
}

// node_modules/@inkline/inkline/helpers/sortByPath.mjs
function sortByPath(path) {
  return (a, b) => {
    return getValueByPath(a, path) > getValueByPath(b, path) ? 1 : getValueByPath(a, path) < getValueByPath(b, path) ? -1 : 0;
  };
}

// node_modules/@inkline/inkline/helpers/toCamelCase.mjs
function toCamelCase(string, from = "dash") {
  const regExp = from === "dash" ? /-([a-z0-9])/g : /_([a-z0-9])/g;
  return string.replace(regExp, (match, p) => p.toUpperCase());
}

// node_modules/@inkline/inkline/helpers/toUnderscoreCase.mjs
function toUnderscoreCase(string, from = "camel") {
  const regExp = from === "camel" ? /([A-Z])/g : /-([a-zA-Z])/g;
  return string.replace(regExp, (match, p) => "_" + p.toLowerCase());
}

// node_modules/@inkline/inkline/helpers/triggerEvent.mjs
function triggerEvent(element, name, rawOptions) {
  if (typeof window === "undefined") {
    return;
  }
  let eventName;
  const options = {
    bubbles: false,
    cancelable: true,
    ...rawOptions
  };
  if (/^mouse|click/.test(name)) {
    eventName = "MouseEvents";
  } else if (/^key/.test(name)) {
    eventName = "KeyboardEvent";
  } else {
    eventName = "HTMLEvents";
  }
  const evt = document.createEvent(eventName);
  evt.initEvent(name, options.bubbles, options.cancelable);
  Object.keys(options).forEach((optionName) => {
    if (optionName !== "bubbles" && optionName !== "cancelable") {
      evt[optionName] = options[optionName];
    }
  });
  element.dispatchEvent ? element.dispatchEvent(evt) : element.fireEvent("on" + name, evt);
  return element;
}

// node_modules/@inkline/inkline/helpers/uid.mjs
function uid(baseId) {
  return `${baseId ? `${baseId}-` : ""}${Math.random().toString(36).substr(2, 9)}`;
}

// node_modules/@inkline/inkline/validation/validators/sameAs.mjs
function sameAs(value, options = {}) {
  if (!options.target) {
    return false;
  }
  const targetSchema = getValueByPath(options.schema(), options.target);
  if (!targetSchema) {
    throw new Error(`Could not find target with name '${options.target}' in 'sameAs' validator.`);
  }
  return value === targetSchema.value;
}

// node_modules/@inkline/inkline/validation/validators/index.mjs
var validators = {
  alpha: alpha2,
  alphanumeric: alphanumeric2,
  custom,
  number,
  email,
  max,
  maxLength,
  min,
  minLength,
  required,
  sameAs
};
function registerValidator(name, validator2) {
  validators[name] = validator2;
}
function unregisterValidator(name) {
  delete validators[name];
}

// node_modules/@inkline/inkline/validation/initialize.mjs
function initialize(schema) {
  const isField = Object.keys(schema).length === 0 || Array.isArray(schema.validators) || schema.hasOwnProperty("value");
  const defaultValues = isField ? { ...defaultValidationValues, ...defaultFieldValidationValues } : defaultValidationValues;
  Object.entries(defaultValues).forEach(([key, value]) => {
    if (!schema.hasOwnProperty(key)) {
      schema[key] = value;
    }
  });
  Object.keys(schema).filter((key) => !reservedValidationFields.includes(key)).forEach((key) => {
    if (typeof schema[key] === "object" || Array.isArray(schema[key])) {
      schema[key] = initialize(schema[key]);
    }
  });
  return schema;
}

// node_modules/@inkline/inkline/i18n/messages/en.mjs
var en = {
  validation: {
    alpha: (params) => {
      let context;
      switch (true) {
        case (params.allowSpaces && params.allowDashes):
          context = "letters, spaces, and dashes";
          break;
        case params.allowSpaces:
          context = "letters and spaces";
          break;
        case params.allowDashes:
          context = "letters and dashes";
          break;
        default:
          context = "letters";
      }
      return `Please enter ${context} only.`;
    },
    alphanumeric: (params) => {
      let context;
      switch (true) {
        case (params.allowSpaces && params.allowDashes):
          context = "letters, numbers, spaces, and dashes";
          break;
        case params.allowSpaces:
          context = "letters, numbers, and spaces";
          break;
        case params.allowDashes:
          context = "letters, numbers, and dashes";
          break;
        default:
          context = "letters and numbers";
      }
      return `Please enter ${context} only.`;
    },
    number: (params) => {
      let context;
      switch (true) {
        case (params.allowNegative && params.allowDecimal):
          context = "positive or negative decimal numbers";
          break;
        case params.allowNegative:
          context = "positive or negative numbers";
          break;
        case params.allowDecimal:
          context = "decimal numbers";
          break;
        default:
          context = "numbers";
      }
      return `Please enter ${context} only.`;
    },
    email: () => "Please enter a valid email address.",
    max: () => "Please enter a maximum value of {value}.",
    maxLength: () => "Please enter up to {value} characters.",
    min: () => "Please enter a minimum value of {value}.",
    minLength: () => "Please enter at least {value} characters.",
    required: () => "Please enter a value for this field.",
    sameAs: () => "Please make sure that the two values match.",
    custom: () => "Please enter a correct value for this field."
  }
};

// node_modules/@inkline/inkline/i18n/translate.mjs
function translate(path, params = {}) {
  const valueByPath = getValueByPath(i18n.messages[i18n.locale], path);
  const string = isFunction(valueByPath) ? valueByPath(params) : valueByPath || path;
  return Object.keys(params).reduce((acc, key) => {
    return acc.replace(new RegExp(`{${key}}`, "g"), `${params[key]}`);
  }, string);
}

// node_modules/@inkline/inkline/i18n/index.mjs
var i18n = {
  locale: "en",
  messages: {
    en
  }
};
function setLocale(locale) {
  i18n.locale = locale;
}

// node_modules/@inkline/inkline/validation/validate.mjs
function validateFormInput(schema, path = "") {
  const errors = [];
  schema.valid = (schema.validators || []).reduce((acc, rawValidator) => {
    const validator2 = typeof rawValidator === "string" ? { name: rawValidator } : rawValidator;
    const valid = validators[validator2.name](schema.value, validator2);
    if (!valid) {
      const { name, message, ...params } = validator2;
      const i18nParams = {
        name: path.split(".").pop(),
        value: schema.value,
        ...params
      };
      const errorMessage = (message instanceof Function ? message() : message) || translate(`validation.${name}`, i18nParams);
      errors.push({ name, message: errorMessage, path });
    }
    return acc && valid;
  }, true);
  schema.invalid = !schema.valid;
  schema.errors = errors;
  return schema;
}
function validateFormGroup(schema, name = "") {
  schema.valid = Object.keys(schema).filter((key) => !reservedValidationFields.includes(key)).reduce((acc, key) => {
    if (Object.keys(schema[key]).length === 0 || schema[key].validators || schema[key].value) {
      schema[key] = validateFormInput(schema[key], `${name}` ? `${name}.${key}` : key);
    } else {
      schema[key] = validateFormGroup(schema[key], `${name}` ? `${name}.${key}` : key);
    }
    return acc && schema[key].valid;
  }, true);
  schema.invalid = !schema.valid;
  return schema;
}
function validate(schema) {
  return validateFormGroup(schema, "");
}

// node_modules/@inkline/inkline/composition-api/useForm.mjs
function useForm(schema) {
  return ref(initialize(schema));
}

// node_modules/@inkline/inkline/controllers/OverlayController.mjs
var OverlayController = {
  instances: {},
  stack: [],
  zIndex: 1050,
  register(instance) {
    if (instance && instance.name) {
      OverlayController.instances[instance.name] = instance;
    }
  },
  unregister(instance) {
    if (instance && instance.name) {
      OverlayController.instances[instance.name] = null;
      delete OverlayController.instances[instance.name];
    }
  },
  open(name) {
    if (typeof window === "undefined") {
      return;
    }
    OverlayController.stack.push(name);
    OverlayController.instances[name].$el.style.zIndex = OverlayController.zIndex++;
  },
  close(name) {
    if (typeof window === "undefined") {
      return;
    }
    OverlayController.stack.splice(OverlayController.stack.indexOf(name), 1);
  },
  getTopOverlay() {
    const topOverlayName = OverlayController.stack.slice(-1)[0] || "";
    return OverlayController.instances[topOverlayName];
  },
  onPressEscape() {
    const topOverlay = OverlayController.getTopOverlay();
    if (topOverlay && topOverlay.closeOnPressEscape) {
      topOverlay.hide();
    }
  }
};
if (typeof window !== "undefined") {
  window.addEventListener("keydown", (e) => {
    if (isKey("esc", e)) {
      OverlayController.onPressEscape();
    }
  });
}

// node_modules/@inkline/inkline/directives/click-outside.mjs
var onClickOutside = (element, binding) => (e) => {
  if (!isVisible(element) || !e.target) {
    return;
  }
  if (element === e.target || element.contains(e.target)) {
    return;
  }
  binding.value(e);
};
var ClickOutsideDirective = {
  beforeMount(element, binding) {
    if (typeof window !== "undefined") {
      on(window.document, "mousedown", onClickOutside(element, binding));
    }
  }
};
var click_outside_default = ClickOutsideDirective;

// node_modules/@inkline/inkline/mixins/computed/classes.mjs
function colorVariantClass(component) {
  let colorClass = component.color;
  if (!colorClass) {
    if (component.$inkline.options.colorMode === "system") {
      colorClass = typeof window !== "undefined" && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    } else {
      colorClass = component.$inkline.options.colorMode;
    }
  }
  return {
    [`-${colorClass}`]: true
  };
}

// node_modules/@inkline/inkline/icons.mjs
var icons_exports = {};
__export(icons_exports, {
  inkCaretDown: () => inkCaretDown,
  inkCheck: () => inkCheck,
  inkChevronDown: () => inkChevronDown,
  inkCircle: () => inkCircle,
  inkDanger: () => inkDanger,
  inkInfo: () => inkInfo,
  inkMinus: () => inkMinus,
  inkPlus: () => inkPlus,
  inkSearch: () => inkSearch,
  inkSort: () => inkSort,
  inkSortAsc: () => inkSortAsc,
  inkSortDesc: () => inkSortDesc,
  inkTimes: () => inkTimes,
  inkWarning: () => inkWarning
});
var inkCaretDown = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "16", height: "28", viewBox: "0 0 16 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "caret-down", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M16 11c0 0.266-0.109 0.516-0.297 0.703l-7 7c-0.187 0.187-0.438 0.297-0.703 0.297s-0.516-0.109-0.703-0.297l-7-7c-0.187-0.187-0.297-0.438-0.297-0.703 0-0.547 0.453-1 1-1h14c0.547 0 1 0.453 1 1z" }, children: [] }] };
var inkCheck = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "check", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M23.625 3.5l-13.125 13.125-6.125-6.125-4.375 4.375 10.5 10.5 17.5-17.5z" }, children: [] }] };
var inkChevronDown = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "chevron-down", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M26.297 12.625l-11.594 11.578c-0.391 0.391-1.016 0.391-1.406 0l-11.594-11.578c-0.391-0.391-0.391-1.031 0-1.422l2.594-2.578c0.391-0.391 1.016-0.391 1.406 0l8.297 8.297 8.297-8.297c0.391-0.391 1.016-0.391 1.406 0l2.594 2.578c0.391 0.391 0.391 1.031 0 1.422z" }, children: [] }] };
var inkCircle = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "28", viewBox: "0 0 24 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "circle", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M24 14c0 6.625-5.375 12-12 12s-12-5.375-12-12 5.375-12 12-12 12 5.375 12 12z" }, children: [] }] };
var inkDanger = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "danger", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M14 2.625c-3.038 0-5.895 1.183-8.043 3.332s-3.332 5.005-3.332 8.043c0 3.038 1.183 5.895 3.332 8.043s5.005 3.332 8.043 3.332c3.038 0 5.895-1.183 8.043-3.332s3.332-5.005 3.332-8.043c0-3.038-1.183-5.895-3.332-8.043s-5.005-3.332-8.043-3.332zM14 0v0c7.732 0 14 6.268 14 14s-6.268 14-14 14c-7.732 0-14-6.268-14-14s6.268-14 14-14zM12.25 19.25h3.5v3.5h-3.5zM12.25 5.25h3.5v10.5h-3.5z" }, children: [] }] };
var inkInfo = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "info", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M12.25 8.313c0-0.722 0.591-1.313 1.313-1.313h0.875c0.722 0 1.313 0.591 1.313 1.313v0.875c0 0.722-0.591 1.313-1.313 1.313h-0.875c-0.722 0-1.313-0.591-1.313-1.313v-0.875z" }, children: [] }, { name: "path", type: "element", value: "", attributes: { d: "M17.5 21h-7v-1.75h1.75v-5.25h-1.75v-1.75h5.25v7h1.75z" }, children: [] }, { name: "path", type: "element", value: "", attributes: { d: "M14 0c-7.732 0-14 6.268-14 14s6.268 14 14 14 14-6.268 14-14-6.268-14-14-14zM14 25.375c-6.282 0-11.375-5.093-11.375-11.375s5.093-11.375 11.375-11.375 11.375 5.093 11.375 11.375-5.093 11.375-11.375 11.375z" }, children: [] }] };
var inkMinus = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "minus", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M0 11.375v5.25c0 0.483 0.392 0.875 0.875 0.875h26.25c0.483 0 0.875-0.392 0.875-0.875v-5.25c0-0.483-0.392-0.875-0.875-0.875h-26.25c-0.483 0-0.875 0.392-0.875 0.875z" }, children: [] }] };
var inkPlus = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "plus", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M27.125 10.5h-9.625v-9.625c0-0.483-0.392-0.875-0.875-0.875h-5.25c-0.483 0-0.875 0.392-0.875 0.875v9.625h-9.625c-0.483 0-0.875 0.392-0.875 0.875v5.25c0 0.483 0.392 0.875 0.875 0.875h9.625v9.625c0 0.483 0.392 0.875 0.875 0.875h5.25c0.483 0 0.875-0.392 0.875-0.875v-9.625h9.625c0.483 0 0.875-0.392 0.875-0.875v-5.25c0-0.483-0.392-0.875-0.875-0.875z" }, children: [] }] };
var inkSearch = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "search", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M27.132 23.827l-6.632-5.641c-0.686-0.617-1.419-0.9-2.011-0.873 1.566-1.834 2.511-4.213 2.511-6.813 0-5.799-4.701-10.5-10.5-10.5s-10.5 4.701-10.5 10.5 4.701 10.5 10.5 10.5c2.6 0 4.98-0.946 6.813-2.511-0.027 0.592 0.256 1.326 0.873 2.011l5.641 6.632c0.966 1.073 2.544 1.164 3.506 0.201s0.872-2.54-0.201-3.506zM10.5 17.5c-3.866 0-7-3.134-7-7s3.134-7 7-7 7 3.134 7 7-3.134 7-7 7z" }, children: [] }] };
var inkSortAsc = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "16", height: "28", viewBox: "0 0 16 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "sort-asc", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M16 11c0 0.547-0.453 1-1 1h-14c-0.547 0-1-0.453-1-1 0-0.266 0.109-0.516 0.297-0.703l7-7c0.187-0.187 0.438-0.297 0.703-0.297s0.516 0.109 0.703 0.297l7 7c0.187 0.187 0.297 0.438 0.297 0.703z" }, children: [] }] };
var inkSortDesc = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "16", height: "28", viewBox: "0 0 16 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "sort-desc", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M16 17c0 0.266-0.109 0.516-0.297 0.703l-7 7c-0.187 0.187-0.438 0.297-0.703 0.297s-0.516-0.109-0.703-0.297l-7-7c-0.187-0.187-0.297-0.438-0.297-0.703 0-0.547 0.453-1 1-1h14c0.547 0 1 0.453 1 1z" }, children: [] }] };
var inkSort = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "16", height: "28", viewBox: "0 0 16 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "sort", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M16 17c0 0.266-0.109 0.516-0.297 0.703l-7 7c-0.187 0.187-0.438 0.297-0.703 0.297s-0.516-0.109-0.703-0.297l-7-7c-0.187-0.187-0.297-0.438-0.297-0.703 0-0.547 0.453-1 1-1h14c0.547 0 1 0.453 1 1zM16 11c0 0.547-0.453 1-1 1h-14c-0.547 0-1-0.453-1-1 0-0.266 0.109-0.516 0.297-0.703l7-7c0.187-0.187 0.438-0.297 0.703-0.297s0.516 0.109 0.703 0.297l7 7c0.187 0.187 0.297 0.438 0.297 0.703z" }, children: [] }] };
var inkTimes = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "times", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M27.745 22.495c-0-0-0-0-0-0l-8.494-8.494 8.494-8.494c0-0 0-0 0-0 0.091-0.091 0.158-0.198 0.2-0.312 0.116-0.311 0.050-0.675-0.2-0.925l-4.013-4.013c-0.25-0.25-0.614-0.316-0.925-0.2-0.114 0.042-0.221 0.109-0.312 0.2 0 0-0 0-0 0l-8.494 8.494-8.494-8.494c-0-0-0-0-0-0-0.091-0.091-0.198-0.158-0.312-0.2-0.311-0.116-0.675-0.050-0.925 0.2l-4.013 4.013c-0.25 0.25-0.316 0.614-0.2 0.925 0.042 0.114 0.109 0.221 0.2 0.312 0 0 0 0 0 0l8.494 8.494-8.494 8.494c-0 0-0 0-0 0-0.091 0.091-0.157 0.198-0.2 0.312-0.116 0.311-0.050 0.675 0.2 0.925l4.013 4.013c0.25 0.25 0.614 0.316 0.925 0.2 0.114-0.042 0.221-0.109 0.312-0.2 0-0 0-0 0-0l8.494-8.494 8.494 8.494c0 0 0 0 0 0 0.092 0.091 0.198 0.158 0.312 0.2 0.311 0.116 0.675 0.050 0.925-0.2l4.013-4.013c0.25-0.25 0.316-0.614 0.2-0.925-0.042-0.114-0.109-0.221-0.2-0.312z" }, children: [] }] };
var inkWarning = { name: "svg", type: "element", value: "", attributes: { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "28", height: "28", viewBox: "0 0 28 28", fill: "currentColor" }, children: [{ name: "title", type: "element", value: "", attributes: {}, children: [{ name: "", type: "text", value: "warning", attributes: {}, children: [] }] }, { name: "path", type: "element", value: "", attributes: { d: "M14 2.537l11.733 23.385h-23.467l11.733-23.385zM14 0c-0.603 0-1.207 0.407-1.665 1.221l-11.951 23.819c-0.916 1.628-0.137 2.96 1.731 2.96h23.77c1.868 0 2.647-1.332 1.731-2.96h0l-11.951-23.819c-0.458-0.814-1.061-1.221-1.665-1.221v0z" }, children: [] }, { name: "path", type: "element", value: "", attributes: { d: "M15.75 22.75c0 0.966-0.784 1.75-1.75 1.75s-1.75-0.784-1.75-1.75c0-0.966 0.784-1.75 1.75-1.75s1.75 0.784 1.75 1.75z" }, children: [] }, { name: "path", type: "element", value: "", attributes: { d: "M14 19.25c-0.966 0-1.75-0.784-1.75-1.75v-5.25c0-0.966 0.784-1.75 1.75-1.75s1.75 0.784 1.75 1.75v5.25c0 0.966-0.784 1.75-1.75 1.75z" }, children: [] }] };

// node_modules/@inkline/inkline/plugin.mjs
var colorModeLocalStorageKey = "inkline-color-mode";
var handleColorMode = (colorMode) => {
  let color;
  if (colorMode === "system") {
    color = matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  } else {
    color = colorMode;
  }
  removeClass(document.body, "-light -dark");
  addClass(document.body, `-${color}`);
};
var defaultOptions = {
  components: {},
  icons: {},
  colorMode: "system",
  locale: "en",
  validateOn: ["input", "blur"],
  color: "",
  size: "",
  routerComponent: "router-link",
  componentOptions: {}
};
function createPrototype({ icons, components, ...options }) {
  return {
    form(schema) {
      return initialize(schema);
    },
    setLocale(locale) {
      setLocale(locale);
    },
    options: reactive(options)
  };
}
var inklineGlobals = {
  prototype: void 0,
  icons: void 0
};
var Inkline = {
  install(app, options = {}) {
    const extendedOptions = {
      ...defaultOptions,
      ...options
    };
    for (const componentIndex in extendedOptions.components) {
      app.component(extendedOptions.components[componentIndex].name, extendedOptions.components[componentIndex]);
    }
    if (typeof window !== "undefined") {
      const storedColorMode = localStorage.getItem(colorModeLocalStorageKey);
      if (storedColorMode) {
        extendedOptions.colorMode = storedColorMode;
      }
    }
    const prototype = createPrototype(extendedOptions);
    inklineGlobals.prototype = prototype;
    app.config.globalProperties.$inkline = prototype;
    app.provide("inkline", prototype);
    const icons = {
      ...icons_exports,
      ...extendedOptions.icons
    };
    app.provide("inklineIcons", icons);
    if (typeof window !== "undefined") {
      watch(() => prototype.options.colorMode, (colorMode) => {
        handleColorMode(colorMode);
        localStorage.setItem(colorModeLocalStorageKey, colorMode);
      });
      const onDarkModeMediaQueryChange = () => {
        if (prototype.options.colorMode === "system") {
          handleColorMode(prototype.options.colorMode);
        }
      };
      const darkModeMediaQuery = matchMedia("(prefers-color-scheme: dark)");
      if (darkModeMediaQuery.addEventListener) {
        darkModeMediaQuery.addEventListener("change", onDarkModeMediaQueryChange);
      } else {
        darkModeMediaQuery.addListener(onDarkModeMediaQueryChange);
      }
      addClass(document.body, "inkline");
      handleColorMode(extendedOptions.colorMode);
    }
  }
};

// node_modules/@inkline/inkline/mixins/props/default.mjs
function defaultPropValue(componentName, propertyName, propertyValue = "") {
  return () => {
    var _a;
    return inklineGlobals.prototype ? ((_a = inklineGlobals.prototype.options.componentOptions[componentName]) == null ? void 0 : _a[propertyName]) ? inklineGlobals.prototype.options.componentOptions[componentName][propertyName] : inklineGlobals.prototype.options[propertyName] : propertyValue;
  };
}

// node_modules/@inkline/inkline/mixins/props/size.mjs
function sizePropValidator(size) {
  return ["", "xs", "sm", "md", "lg", "xl", "xxl"].includes(size);
}

// node_modules/@inkline/inkline/mixins/CollapsibleMixin.mjs
var CollapsibleMixin_default = defineComponent({
  props: {
    collapse: {
      type: [String, Boolean],
      default: "md"
    },
    modelValue: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue"],
  data() {
    return {
      open: this.modelValue,
      windowWidth: typeof window !== "undefined" ? window.innerWidth : 0
    };
  },
  computed: {
    collapsibleClasses() {
      return {
        "-open": this.open,
        "-collapsible": this.collapsible,
        [`-collapse-${this.collapse}`]: Boolean(this.collapse)
      };
    },
    collapsible() {
      if (this.collapse === true || this.collapse === false) {
        return this.collapse;
      }
      return this.windowWidth <= breakpoints[this.collapse][1];
    }
  },
  watch: {
    modelValue(value) {
      this.open = value;
    }
  },
  created() {
    if (typeof window !== "undefined") {
      on(window, "resize", this.onWindowResize);
      this.onWindowResize();
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      off(window, "resize", this.onWindowResize);
    }
  },
  methods: {
    setOpen(value) {
      this.open = value;
      this.$emit("update:modelValue", this.open);
    },
    toggleOpen() {
      this.open = !this.open;
      this.$emit("update:modelValue", this.open);
    },
    onWindowResize() {
      if (this.collapse === true || this.collapse === false || typeof window === "undefined") {
        return;
      }
      const windowWidth = window.innerWidth;
      if (this.windowWidth <= breakpoints[this.collapse][1] && windowWidth > breakpoints[this.collapse][1]) {
        this.setOpen(false);
      }
      this.windowWidth = window.innerWidth;
    }
  }
});

// node_modules/@inkline/inkline/mixins/FormComponentMixin.mjs
var FormComponentMixin_default = defineComponent({
  inject: {
    formGroup: {
      default: () => ({})
    },
    form: {
      default: () => ({})
    }
  },
  computed: {
    isDisabled() {
      return this.disabled || this.form.isDisabled || this.formGroup.isDisabled;
    },
    isReadonly() {
      return this.readonly || this.form.isReadonly || this.formGroup.isReadonly;
    },
    parent() {
      if (this.formGroup.$) {
        return this.formGroup;
      }
      return this.form;
    },
    schema() {
      const parentSchema = this.parent.schema || {};
      if (this.name !== "") {
        return getValueByPath(parentSchema, `${this.name}`);
      }
      return parentSchema;
    }
  }
});

// node_modules/@inkline/inkline/mixins/LinkableMixin.mjs
var LinkableMixin_default = defineComponent({
  props: {
    tag: {
      type: String,
      default: "a"
    }
  },
  computed: {
    isTag() {
      return this.$attrs.to ? this.routerComponent : this.$attrs.href ? "a" : this.tag;
    },
    isComponent() {
      return this.isTag === this.routerComponent;
    },
    routerComponent() {
      return this.$inkline.options.routerComponent;
    }
  }
});

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max2 = Math.max;
var min2 = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min3, value, max3) {
  return max2(min3, min2(value, max3));
}
function withinMaxClamp(min3, value, max3) {
  var v = within(min3, value, max3);
  return v > max3 ? max3 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min3 = paddingObject[minProp];
  var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min3, center, max3);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min3 = offset2 + overflow[mainSide];
    var max3 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min2(min3, tetherMin) : min3, offset2, tether ? max2(max3, tetherMax) : max3);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/@inkline/inkline/mixins/PopupMixin.mjs
var offsetModifier = (offset2) => ({
  name: "offset",
  options: {
    offset: [0, offset2]
  }
});
var arrowModifier = () => ({
  name: "arrow",
  options: {
    padding: 6
  }
});
var preventOverflowModifier = () => ({
  name: "preventOverflow",
  options: {
    padding: 8
  }
});
var computeStylesModifier = () => ({
  name: "computeStyles",
  options: {
    gpuAcceleration: false,
    adaptive: false
  }
});
var useBaseModifiers = ({ offset: offset2 }) => [
  offsetModifier(offset2),
  arrowModifier(),
  preventOverflowModifier(),
  computeStylesModifier()
];
var PopupMixin_default = defineComponent({
  props: {
    placement: {
      type: String,
      default: "auto"
    },
    offset: {
      type: Number,
      default: 6
    },
    popperOptions: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      popperInstance: void 0
    };
  },
  watch: {
    placement(placement) {
      if (this.popperInstance) {
        this.popperInstance.setOptions({ placement });
      }
    }
  },
  beforeUnmount() {
    this.destroyPopper();
  },
  methods: {
    createPopper() {
      if (typeof window === "undefined") {
        return;
      }
      const modifiers = useBaseModifiers({ offset: this.offset });
      this.popperInstance = createPopper3(this.$refs.wrapper, this.$refs.popup, {
        strategy: "fixed",
        placement: this.placement,
        modifiers,
        ...this.popperOptions
      });
    },
    destroyPopper() {
      if (this.popperInstance) {
        this.popperInstance.destroy();
        this.popperInstance = void 0;
      }
    }
  }
});

// node_modules/@inkline/inkline/mixins/PopupControlsMixin.mjs
var PopupControlsMixin_default = defineComponent({
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    trigger: {
      type: Array,
      default: () => ["hover", "click", "focus"]
    },
    interactable: {
      type: Boolean,
      default: true
    },
    hoverHideDelay: {
      type: Number,
      default: 300
    }
  },
  emits: ["update:modelValue", "click-outside"],
  data() {
    return {
      visible: this.modelValue,
      triggerStack: 0,
      hoverHideTransition: false
    };
  },
  watch: {
    modelValue(value) {
      if (value) {
        this.show();
      } else {
        this.hide();
      }
    }
  },
  mounted() {
    if (!this.$slots.default) {
      throw new Error("Popup components require one child element to be used as trigger.");
    }
    this.addEventListeners();
  },
  beforeUnmount() {
    this.removeEventListeners();
  },
  methods: {
    show() {
      if (this.disabled || this.visible) {
        return;
      }
      this.triggerStack += 1;
      this.visible = true;
      this.createPopper();
      this.$emit("update:modelValue", true);
    },
    hide() {
      if (this.disabled || !this.visible) {
        return;
      }
      this.triggerStack -= 1;
      if (this.triggerStack <= 0) {
        this.triggerStack = 0;
        this.visible = false;
        this.$emit("update:modelValue", false);
      }
    },
    hoverShow() {
      this.hoverHideTransition = false;
      this.show();
    },
    hoverHide() {
      this.hoverHideTransition = true;
      setTimeout(() => {
        if (this.hoverHideTransition) {
          this.hide();
        }
      }, this.hoverHideDelay);
    },
    onClick() {
      if (this.visible) {
        this.hide();
      } else {
        this.show();
      }
    },
    onClickOutside(event) {
      if (this.visible) {
        this.$emit("click-outside", event);
      }
      if (this.modelValue)
        return;
      this.hide();
    },
    addEventListeners() {
      [].concat(this.trigger).forEach((trigger) => {
        switch (trigger) {
          case "hover":
            on(this.$refs.trigger, "mouseenter", this.interactable ? this.hoverShow : this.show);
            on(this.$refs.trigger, "mouseleave", this.interactable ? this.hoverHide : this.hide);
            if (this.interactable) {
              on(this.$refs.popup, "mouseenter", this.hoverShow);
              on(this.$refs.popup, "mouseleave", this.hoverHide);
            }
            break;
          case "click":
            on(this.$refs.trigger, "click", this.onClick);
            break;
          case "focus":
            for (const child of this.$refs.trigger.children) {
              on(child, "focus", this.show);
              on(child, "blur", this.hide);
            }
            break;
          default:
            break;
        }
      });
    },
    removeEventListeners() {
      [].concat(this.trigger).forEach((trigger) => {
        switch (trigger) {
          case "hover":
            off(this.$refs.trigger, "mouseenter", this.interactable ? this.hoverShow : this.show);
            off(this.$refs.trigger, "mouseleave", this.interactable ? this.hoverHide : this.hide);
            if (this.interactable) {
              off(this.$refs.popup, "mouseenter", this.hoverShow);
              off(this.$refs.popup, "mouseleave", this.hoverHide);
            }
            break;
          case "click":
            off(this.$refs.trigger, "click", this.onClick);
            break;
          case "focus":
            for (const child of this.$refs.trigger.children) {
              off(child, "focus", this.show);
              off(child, "blur", this.hide);
            }
            break;
          default:
            break;
        }
      });
    },
    focusTrigger() {
      for (const child of this.$refs.trigger.children) {
        if (focusFirstDescendant(child)) {
          child.focus();
          break;
        }
      }
    }
  }
});

// node_modules/@inkline/inkline/transitions/index.mjs
import { default as default60 } from "/Users/mayukhdas/dev/webdevel/CS6131/node_modules/@inkline/inkline/transitions/IExpandTransition/index.vue";
export {
  click_outside_default as ClickOutside,
  CollapsibleMixin_default as CollapsibleMixin,
  FormComponentMixin_default as FormComponentMixin,
  default19 as IAlert,
  default20 as IBadge,
  default21 as IBreadcrumb,
  default2 as IBreadcrumbItem,
  default22 as IButton,
  default23 as IButtonGroup,
  default26 as ICard,
  default27 as ICheckbox,
  default3 as ICheckboxGroup,
  default28 as ICollapsible,
  default4 as ICollapsibleItem,
  default24 as IColumn,
  default25 as IContainer,
  default29 as IDropdown,
  default5 as IDropdownDivider,
  default6 as IDropdownItem,
  default60 as IExpandTransition,
  default30 as IForm,
  default8 as IFormError,
  default7 as IFormGroup,
  default9 as IFormLabel,
  default31 as IHamburgerMenu,
  default32 as IHeader,
  default33 as IIcon,
  default34 as IInput,
  default37 as ILayout,
  default38 as ILayoutAside,
  default39 as ILayoutContent,
  default40 as ILayoutFooter,
  default41 as ILayoutHeader,
  default42 as IListGroup,
  default10 as IListGroupItem,
  default43 as ILoader,
  default44 as IMark,
  default45 as IMedia,
  default46 as IModal,
  default47 as INav,
  default11 as INavItem,
  default48 as INavbar,
  default12 as INavbarBrand,
  default13 as INavbarCollapsible,
  default35 as INumberInput,
  default49 as IPagination,
  default50 as IPopover,
  default51 as IProgress,
  default14 as IProgressBar,
  default52 as IRadio,
  default15 as IRadioGroup,
  default53 as IRow,
  default54 as ISelect,
  default16 as ISelectOption,
  default55 as ISidebar,
  default17 as ITab,
  default18 as ITabTitle,
  default56 as ITable,
  default57 as ITabs,
  default36 as ITextarea,
  default58 as IToggle,
  default59 as ITooltip,
  Inkline,
  LinkableMixin_default as LinkableMixin,
  OverlayController,
  PopupControlsMixin_default as PopupControlsMixin,
  PopupMixin_default as PopupMixin,
  _off,
  _on,
  addClass,
  addEventListenerBinding,
  alpha2 as alpha,
  alphanumeric2 as alphanumeric,
  attachEventBinding,
  breakpointClass,
  breakpointKeys,
  breakpoints,
  capitalizeFirst,
  clone,
  colorModeLocalStorageKey,
  colorVariantClass,
  components_exports as components,
  createPrototype,
  custom,
  debounce,
  defaultFieldValidationValues,
  defaultOptions,
  defaultPropValue,
  defaultValidationValues,
  detachEventBinding,
  email,
  eventValueMap,
  focusAttempt,
  focusFirstDescendant,
  focusLastDescendant,
  getStyleProperty,
  getValueByPath,
  handleColorMode,
  hasClass,
  hashString,
  i18n,
  initialize,
  inklineGlobals,
  isFocusable,
  isFunction,
  isKey,
  isMobile,
  isVisible,
  keymap,
  markSearchString,
  max,
  maxLength,
  memoize,
  min,
  minLength,
  number,
  off,
  on,
  once,
  querySelector,
  querySelectorAll,
  registerValidator,
  removeClass,
  removeEventListenerBinding,
  renderSvg,
  required,
  reservedValidationFields,
  sameAs,
  setLocale,
  setValueByPath,
  setValuesAlongPath,
  sizePropValidator,
  slugify,
  sortByPath,
  toCamelCase,
  toDashCase,
  toUnderscoreCase,
  translate,
  triggerEvent,
  trim,
  uid,
  unregisterValidator,
  useForm,
  validate,
  validateFormGroup,
  validateFormInput,
  validators
};
//# sourceMappingURL=@inkline_inkline.js.map
